"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeType = exports.extractWritableColumnNamesFrom = exports.extractColumnNamesFrom = exports.extractWritableColumnsFrom = exports.extractColumnsFrom = exports.prefixMapForGuidedSplitDotted = exports.prefixMapForSplitDotted = exports.prefixDotted = exports.mapForGuidedSplit = exports.prefixMapForGuidedSplitCapitalized = exports.prefixMapForSplitCapitalized = exports.prefixCapitalized = void 0;
const values_1 = require("../expressions/values");
const Column_1 = require("../utils/Column");
function prefixCapitalized(obj, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        result[prefix + key.substr(0, 1).toUpperCase() + key.substr(1)] = obj[key];
    }
    return result;
}
exports.prefixCapitalized = prefixCapitalized;
function prefixMapForSplitCapitalized(obj, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        result[key] = prefix + key.substr(0, 1).toUpperCase() + key.substr(1);
    }
    return result;
}
exports.prefixMapForSplitCapitalized = prefixMapForSplitCapitalized;
function prefixMapForGuidedSplitCapitalized(obj, reference, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        const r = reference[key];
        if ((0, values_1.isValueSource)(r) && (0, values_1.__getValueSourcePrivate)(r).__optionalType === 'required') {
            result[key] = prefix + key.substr(0, 1).toUpperCase() + key.substr(1) + '!';
        }
        else {
            result[key] = prefix + key.substr(0, 1).toUpperCase() + key.substr(1);
        }
    }
    return result;
}
exports.prefixMapForGuidedSplitCapitalized = prefixMapForGuidedSplitCapitalized;
function mapForGuidedSplit(obj, reference) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        const r = reference[key];
        if ((0, values_1.isValueSource)(r) && (0, values_1.__getValueSourcePrivate)(r).__optionalType === 'required') {
            result[key] = key + '!';
        }
        else {
            result[key] = key;
        }
    }
    return result;
}
exports.mapForGuidedSplit = mapForGuidedSplit;
function prefixDotted(obj, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        result[prefix + '.' + key] = obj[key];
    }
    return result;
}
exports.prefixDotted = prefixDotted;
function prefixMapForSplitDotted(obj, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        result[key] = prefix + '.' + key;
    }
    return result;
}
exports.prefixMapForSplitDotted = prefixMapForSplitDotted;
function prefixMapForGuidedSplitDotted(obj, reference, prefix) {
    if (!obj) {
        return obj;
    }
    const result = {};
    for (let key in obj) {
        const r = reference[key];
        if ((0, values_1.isValueSource)(r) && (0, values_1.__getValueSourcePrivate)(r).__optionalType === 'required') {
            result[key] = prefix + '.' + key + '!';
        }
        else {
            result[key] = prefix + '.' + key;
        }
    }
    return result;
}
exports.prefixMapForGuidedSplitDotted = prefixMapForGuidedSplitDotted;
function extractColumnsFrom(obj, exclude) {
    if (!obj) {
        return obj;
    }
    const ignore = {};
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true;
        }
    }
    const result = {};
    for (let key in obj) {
        if (key in ignore) {
            continue;
        }
        const value = obj[key];
        if ((0, values_1.isValueSource)(value)) {
            result[key] = value;
        }
    }
    return result;
}
exports.extractColumnsFrom = extractColumnsFrom;
function extractWritableColumnsFrom(obj, exclude) {
    if (!obj) {
        return obj;
    }
    const ignore = {};
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true;
        }
    }
    const result = {};
    for (let key in obj) {
        if (key in ignore) {
            continue;
        }
        const value = obj[key];
        if ((0, Column_1.isColumn)(value)) {
            if (!(0, Column_1.__getColumnPrivate)(value).__isComputed) {
                result[key] = value;
            }
        }
    }
    return result;
}
exports.extractWritableColumnsFrom = extractWritableColumnsFrom;
function extractColumnNamesFrom(obj, exclude) {
    if (!obj) {
        return [];
    }
    const ignore = {};
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true;
        }
    }
    const result = [];
    for (let key in obj) {
        if (key in ignore) {
            continue;
        }
        const value = obj[key];
        if ((0, values_1.isValueSource)(value)) {
            result.push(key);
        }
    }
    return result;
}
exports.extractColumnNamesFrom = extractColumnNamesFrom;
function extractWritableColumnNamesFrom(obj, exclude) {
    if (!obj) {
        return [];
    }
    const ignore = {};
    if (exclude) {
        for (let i = 0, length = exclude.length; i < length; i++) {
            ignore[exclude[i]] = true;
        }
    }
    const result = [];
    for (let key in obj) {
        if (key in ignore) {
            continue;
        }
        const value = obj[key];
        if ((0, Column_1.isColumn)(value)) {
            if (!(0, Column_1.__getColumnPrivate)(value).__isComputed) {
                result.push(key);
            }
        }
    }
    return result;
}
exports.extractWritableColumnNamesFrom = extractWritableColumnNamesFrom;
function mergeType(value) {
    return value;
}
exports.mergeType = mergeType;
