import type { ITableOrView } from "../utils/ITableOrView";
import { IfValueSource, BooleanValueSource, IAnyBooleanValueSource, IStringIntValueSource, StringIntValueSource, IStringNumberValueSource, StringNumberValueSource, IIntValueSource, IntValueSource, INumberValueSource, NumberValueSource, ITypeSafeBigintValueSource, TypeSafeBigintValueSource, IBigintValueSource, BigintValueSource, IStringDoubleValueSource, StringDoubleValueSource, IDoubleValueSource, DoubleValueSource, ITypeSafeStringValueSource, TypeSafeStringValueSource, IStringValueSource, StringValueSource, ILocalDateValueSource, LocalDateValueSource, IDateValueSource, DateValueSource, ILocalTimeValueSource, LocalTimeValueSource, ITimeValueSource, TimeValueSource, ILocalDateTimeValueSource, LocalDateTimeValueSource, IDateTimeValueSource, DateTimeValueSource, IEqualableValueSource, EqualableValueSource, IComparableValueSource, ComparableValueSource, IValueSource, AnyValueSource, MergeOptionalUnion } from "../expressions/values";
import type { ifValueSourceType, optionalType, tableOrView, valueType } from "../utils/symbols";
import type { ColumnKeys, WritableColumnKeys } from "./types";
declare type OnlyStringKey<KEY> = KEY extends string ? KEY : never;
export declare function prefixCapitalized<O extends object, PREFIX extends string>(obj: O, prefix: PREFIX): {
    [K in OnlyStringKey<keyof O> as `${PREFIX}${Capitalize<K>}`]: O[K];
};
export declare function prefixMapForSplitCapitalized<O extends object, PREFIX extends string>(obj: O, prefix: PREFIX): {
    [K in OnlyStringKey<keyof O> as K]: `${PREFIX}${Capitalize<K>}`;
};
declare type CapitalizedGuided<PREFIX extends string, KEY extends string, REFERENCE extends object> = KEY extends keyof REFERENCE ? (REFERENCE[KEY] extends IValueSource<any, any, any, infer OPTIONAL_TYPE> ? (OPTIONAL_TYPE extends 'required' ? `${PREFIX}${Capitalize<KEY>}!` : `${PREFIX}${Capitalize<KEY>}`) : `${PREFIX}${Capitalize<KEY>}`) : `${PREFIX}${Capitalize<KEY>}`;
export declare function prefixMapForGuidedSplitCapitalized<O extends object, R extends ITableOrView<any> | {
    [KEY in keyof O]?: AnyValueSource;
}, PREFIX extends string>(obj: O, reference: R, prefix: PREFIX): {
    [K in OnlyStringKey<keyof O> as K]: CapitalizedGuided<PREFIX, K, R>;
};
declare type NameGuided<KEY extends string, REFERENCE extends object> = KEY extends keyof REFERENCE ? (REFERENCE[KEY] extends IValueSource<any, any, any, infer OPTIONAL_TYPE> ? (OPTIONAL_TYPE extends 'required' ? `${KEY}!` : KEY) : KEY) : KEY;
export declare function mapForGuidedSplit<O extends object, R extends ITableOrView<any> | {
    [KEY in keyof O]?: AnyValueSource;
}>(obj: O, reference: R): {
    [K in OnlyStringKey<keyof O> as K]: NameGuided<K, R>;
};
export declare function prefixDotted<O extends object, PREFIX extends string>(obj: O, prefix: PREFIX): {
    [K in OnlyStringKey<keyof O> as `${PREFIX}.${K}`]-?: O[K];
};
export declare function prefixMapForSplitDotted<O extends object, PREFIX extends string>(obj: O, prefix: PREFIX): {
    [K in OnlyStringKey<keyof O> as K]-?: `${PREFIX}.${K}`;
};
declare type DottedGuided<PREFIX extends string, KEY extends string, REFERENCE extends object> = KEY extends keyof REFERENCE ? (REFERENCE[KEY] extends IValueSource<any, any, any, infer OPTIONAL_TYPE> ? (OPTIONAL_TYPE extends 'required' ? `${PREFIX}.${KEY}!` : `${PREFIX}.${KEY}`) : `${PREFIX}.${KEY}`) : `${PREFIX}.${KEY}`;
export declare function prefixMapForGuidedSplitDotted<O extends object, R extends ITableOrView<any> | {
    [KEY in keyof O]?: AnyValueSource;
}, PREFIX extends string>(obj: O, reference: R, prefix: PREFIX): {
    [K in OnlyStringKey<keyof O> as K]: DottedGuided<PREFIX, K, R>;
};
export declare function extractColumnsFrom<O extends object, EXCLUDE extends ColumnKeys<O> = never>(obj: O, exclude?: EXCLUDE[]): {
    [K in Exclude<ColumnKeys<O>, EXCLUDE>]: O[K];
};
export declare function extractWritableColumnsFrom<O extends object, EXCLUDE extends ColumnKeys<O> = never>(obj: O, exclude?: EXCLUDE[]): {
    [K in Exclude<WritableColumnKeys<O>, EXCLUDE>]: O[K];
};
export declare function extractColumnNamesFrom<O extends object, EXCLUDE extends ColumnKeys<O> = never>(obj: O, exclude?: EXCLUDE[]): Exclude<ColumnKeys<O>, EXCLUDE>[];
export declare function extractWritableColumnNamesFrom<O extends object, EXCLUDE extends ColumnKeys<O> = never>(obj: O, exclude?: EXCLUDE[]): Exclude<WritableColumnKeys<O>, EXCLUDE>[];
declare type HasIfValueSource<VALUE> = VALUE extends {
    [ifValueSourceType]: 'IfValueSource';
} ? true : never;
export declare function mergeType<VALUE extends IAnyBooleanValueSource<any, any>>(value: VALUE): true extends HasIfValueSource<VALUE> ? IfValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>> : BooleanValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends IStringIntValueSource<any, any>>(value: VALUE): StringIntValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends IStringNumberValueSource<any, any>>(value: VALUE): StringNumberValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends IIntValueSource<any, any>>(value: VALUE): IntValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends INumberValueSource<any, any>>(value: VALUE): NumberValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends ITypeSafeBigintValueSource<any, any>>(value: VALUE): TypeSafeBigintValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends IBigintValueSource<any, any>>(value: VALUE): BigintValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends IStringDoubleValueSource<any, any>>(value: VALUE): StringDoubleValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends IStringNumberValueSource<any, any>>(value: VALUE): StringNumberValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends IDoubleValueSource<any, any>>(value: VALUE): DoubleValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends INumberValueSource<any, any>>(value: VALUE): NumberValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends ITypeSafeStringValueSource<any, any>>(value: VALUE): TypeSafeStringValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends IStringValueSource<any, any>>(value: VALUE): StringValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends ILocalDateValueSource<any, any>>(value: VALUE): LocalDateValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends IDateValueSource<any, any>>(value: VALUE): DateValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends ILocalTimeValueSource<any, any>>(value: VALUE): LocalTimeValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends ITimeValueSource<any, any>>(value: VALUE): TimeValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends ILocalDateTimeValueSource<any, any>>(value: VALUE): LocalDateTimeValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<VALUE extends IDateTimeValueSource<any, any>>(value: VALUE): DateTimeValueSource<VALUE[typeof tableOrView], MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<TYPE_NAME, VALUE extends IEqualableValueSource<any, any, TYPE_NAME, any>>(value: VALUE & IEqualableValueSource<any, any, TYPE_NAME, any>): EqualableValueSource<VALUE[typeof tableOrView], VALUE[typeof valueType], TYPE_NAME, MergeOptionalUnion<VALUE[typeof optionalType]>>;
export declare function mergeType<TYPE_NAME, VALUE extends IComparableValueSource<any, any, TYPE_NAME, any>>(value: VALUE & IComparableValueSource<any, any, TYPE_NAME, any>): ComparableValueSource<VALUE[typeof tableOrView], VALUE[typeof valueType], TYPE_NAME, MergeOptionalUnion<VALUE[typeof optionalType]>>;
export {};
