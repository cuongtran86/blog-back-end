import { AnyDB } from "../databases";
import type { AnyValueSource, IValueSource, OptionalType, OptionalTypeRequiredOrAny, RemapIValueSourceTypeWithOptionalType, ValueSource, ValueSourceOf, ValueSourceValueTypeForRequiredInOptionalObject, ValueSourceValueTypeForObjectResult, ValueSourceValueTypeForOptionalObjectResultSameOuterJoin } from "../expressions/values";
import { NoTableOrViewRequired, OUTER_JOIN_SOURCE, ITableOrViewRef } from "./ITableOrView";
import { database } from "./symbols";
export declare type ResultObjectValues<COLUMNS> = FixOptionalProperties<{
    [P in keyof COLUMNS]: COLUMNS[P] extends AnyValueSource | undefined ? ValueSourceValueTypeForObjectResult<NonNullable<COLUMNS[P]>> : InnerResultObjectValues<NonNullable<COLUMNS[P]>>;
}>;
export declare type RequiredColumnNames<T> = T extends AnyValueSource ? 'result' : 'any' extends T ? never : RequiredInnerColumnNames<T, ''>;
declare type RequiredInnerColumnNames<T, PREFIX extends string> = {
    [K in keyof T]-?: K extends string ? T[K] extends AnyValueSource | undefined ? ({} extends Pick<T, K> ? never : `${PREFIX}${K}`) : RequiredInnerColumnNames<T[K], `${PREFIX}${K}.`> : never;
}[keyof T];
export declare type RequiredKeysOfPickingColumns<T> = T extends AnyValueSource ? never : {
    [K in keyof T]-?: {} extends Pick<T, K> ? never : K;
}[keyof T];
export declare type ColumnGuard<T> = T extends null | undefined ? never : T extends never ? never : T extends AnyValueSource ? never : unknown;
export declare type GuidedObj<T> = T & {
    [K in keyof T as K extends string | number ? `${K}!` : never]-?: NonNullable<T[K]>;
} & {
    [K in keyof T as K extends string | number ? `${K}?` : never]?: T[K];
};
export declare type GuidedPropName<T> = T extends `${infer Q}!` ? Q : T extends `${infer Q}?` ? Q : T;
export declare type ValueOf<T> = T[keyof T];
export declare type FixOptionalProperties<RESULT> = undefined extends string ? RESULT : {
    [P in keyof OptionalMap<RESULT>]: true extends OptionalMap<RESULT> ? RESULT[P] : NonNullable<RESULT[P]>;
};
declare type OptionalMap<TYPE> = {
    [P in MandatoryPropertiesOf<TYPE>]-?: true;
} & {
    [P in OptionalPropertiesOf<TYPE>]?: false;
};
export declare type MandatoryPropertiesOf<TYPE> = ({
    [K in keyof TYPE]-?: null | undefined extends TYPE[K] ? never : (null extends TYPE[K] ? never : (undefined extends TYPE[K] ? never : K));
})[keyof TYPE];
export declare type OptionalPropertiesOf<TYPE> = ({
    [K in keyof TYPE]-?: null | undefined extends TYPE[K] ? K : (null extends TYPE[K] ? K : (undefined extends TYPE[K] ? K : never));
})[keyof TYPE];
export declare type ColumnsForCompound<TABLE_OR_VIEW extends ITableOrViewRef<AnyDB>, COLUMNS> = COLUMNS extends AnyValueSource ? RemapIValueSourceTypeWithOptionalType<TABLE_OR_VIEW, COLUMNS, CompoundColumnOptionalType<COLUMNS>> : InnerColumnsForCompound<TABLE_OR_VIEW, COLUMNS>;
declare type InnerColumnsForCompound<TABLE_OR_VIEW extends ITableOrViewRef<AnyDB>, COLUMNS> = {
    [K in keyof COLUMNS]: COLUMNS[K] extends AnyValueSource | undefined ? RemapIValueSourceTypeWithOptionalType<TABLE_OR_VIEW, COLUMNS[K], CompoundColumnOptionalType<COLUMNS[K]>> : InnerColumnsForCompound<TABLE_OR_VIEW, COLUMNS>;
};
declare type CompoundColumnOptionalType<COLUMN> = COLUMN extends IValueSource<any, any, any, infer OPTIONAL_TYPE> ? OptionalTypeRequiredOrAny<OPTIONAL_TYPE> : never;
declare type InnerResultObjectValues<COLUMNS> = ContainsRequiredInOptionalObject<COLUMNS> extends true ? FixOptionalProperties<{
    [P in keyof COLUMNS]: COLUMNS[P] extends AnyValueSource | undefined ? ValueSourceValueTypeForRequiredInOptionalObject<NonNullable<COLUMNS[P]>> : InnerResultObjectValues<NonNullable<COLUMNS[P]>>;
}> | undefined : AllFromSameLeftJoinWithOriginallyRequired<COLUMNS> extends true ? FixOptionalProperties<{
    [P in keyof COLUMNS]: COLUMNS[P] extends AnyValueSource | undefined ? ValueSourceValueTypeForOptionalObjectResultSameOuterJoin<NonNullable<COLUMNS[P]>> : InnerResultObjectValues<NonNullable<COLUMNS[P]>>;
}> | undefined : ContainsRequired<COLUMNS> extends true ? FixOptionalProperties<{
    [P in keyof COLUMNS]: COLUMNS[P] extends AnyValueSource | undefined ? ValueSourceValueTypeForObjectResult<NonNullable<COLUMNS[P]>> : InnerResultObjectValues<NonNullable<COLUMNS[P]>>;
}> : FixOptionalProperties<{
    [P in keyof COLUMNS]: COLUMNS[P] extends AnyValueSource | undefined ? ValueSourceValueTypeForObjectResult<NonNullable<COLUMNS[P]>> : InnerResultObjectValues<NonNullable<COLUMNS[P]>>;
}> | undefined;
export declare type InnerResultObjectValuesForAggregatedArray<COLUMNS> = NonNullable<InnerResultObjectValues<COLUMNS>>;
declare type ContainsRequiredInOptionalObject<TYPE> = FalseWhenNever<({
    [K in keyof TYPE]-?: TYPE[K] extends IValueSource<any, any, any, infer OPTIONAL_TYPE> | undefined ? IsRequiredInOptionalObject<OPTIONAL_TYPE> : never;
})[keyof TYPE]>;
declare type ContainsRequired<TYPE> = FalseWhenNever<({
    [K in keyof TYPE]-?: TYPE[K] extends IValueSource<any, any, any, infer OPTIONAL_TYPE> | undefined ? IsRequired<OPTIONAL_TYPE> : InnerObjectIsRequired<TYPE[K]> extends true ? true : never;
})[keyof TYPE]>;
declare type InnerObjectIsRequired<TYPE> = ContainsRequiredInOptionalObject<TYPE> extends true ? false : AllFromSameLeftJoinWithOriginallyRequired<TYPE> extends true ? false : ContainsRequired<TYPE>;
declare type AllFromSameLeftJoinWithOriginallyRequired<TYPE> = FalseWhenNever<({
    [K in keyof TYPE]-?: TYPE[K] extends ValueSource<infer T, any, any, infer OPTIONAL_TYPE> | undefined ? OUTER_JOIN_SOURCE<any, any> extends T ? (InnerTables<TYPE> | NoTableOrViewRequired<T[typeof database]> extends T | NoTableOrViewRequired<T[typeof database]> ? IsOriginallyRequired<OPTIONAL_TYPE> : false) : T extends NoTableOrViewRequired<T[typeof database]> ? never : false : never;
})[keyof TYPE]>;
declare type InnerTables<TYPE> = ({
    [K in keyof TYPE]-?: TYPE[K] extends ValueSourceOf<infer T> | undefined ? T : never;
})[keyof TYPE];
declare type IsRequiredInOptionalObject<OPTIONAL_TYPE extends OptionalType> = 'any' extends OPTIONAL_TYPE ? never : 'requiredInOptionalObject' extends OPTIONAL_TYPE ? true : never;
declare type IsOriginallyRequired<OPTIONAL_TYPE extends OptionalType> = 'any' extends OPTIONAL_TYPE ? never : 'originallyRequired' extends OPTIONAL_TYPE ? true : never;
declare type IsRequired<OPTIONAL_TYPE extends OptionalType> = 'any' extends OPTIONAL_TYPE ? never : 'required' extends OPTIONAL_TYPE ? true : never;
declare type FalseWhenNever<T> = [T] extends [never] ? false : T;
export {};
/**
 * Alternative solution that allows to expose the inner objects in the with, but typescript get frozen
 * This implementation doesn't deal when a inner property is used alone. See the case when in this view the inner property
 * is requiredInOptionalObject but that property is used in a way that flag make no sence any more
 */
